"""Graph-based anomaly detection utilities.

This module defines a simple :class:`GraphAnomalyDetector` that loads entity
and relationship data into Neo4j and runs a degree-based anomaly detection
algorithm.  The implementation relies on :class:`~graph.neo4j_client.Neo4jClient`
which uses the official Neo4j driver when available and falls back to an
in-memory ``networkx`` representation for tests.

Nodes in the graph use the following labels:

``User`` -- a person interacting with the system.
``Facility`` -- physical location or site.
``Device`` -- hardware associated with a facility.
``Event`` -- an action generated by a device or user.

Relationships follow the schema:

``(User)-[:ACCESS]->(Facility)``
``(Facility)-[:CONTAINS]->(Device)``
``(Device)-[:GENERATED]->(Event)``
``(User)-[:TRIGGERED]->(Event)``

An event is flagged as anomalous when its degree (number of connected nodes)
exceeds ``min_degree``.  This is a rudimentary heuristic but serves as a
placeholder for more sophisticated graph algorithms or GNN models.
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Iterable, Mapping, Sequence

from graph.neo4j_client import Neo4jClient


@dataclass
class GraphAnomalyDetector:
    """Detect anomalies in a Neo4j graph.

    Parameters
    ----------
    neo4j_client:
        Client used to communicate with Neo4j.  In tests this can be the
        in-memory variant provided by :mod:`graph.neo4j_client`.
    min_degree:
        Minimum number of relationships an event must have before being flagged
        as anomalous.
    """

    neo4j_client: Neo4jClient
    min_degree: int = 3

    # ------------------------------------------------------------------
    # Data loading helpers
    # ------------------------------------------------------------------
    def load_entities(
        self,
        users: Sequence[Mapping[str, object]],
        facilities: Sequence[Mapping[str, object]],
        devices: Sequence[Mapping[str, object]],
        events: Sequence[Mapping[str, object]],
        relationships: Mapping[str, Iterable[tuple[str, str]]],
    ) -> None:
        """Load entities and relationships into Neo4j.

        The input sequences contain dictionaries describing the nodes.  Each
        dictionary **must** include an ``id`` key which is used as the node
        identifier within the graph.
        """

        for user in users:
            self.neo4j_client.add_node(str(user["id"]), label="User", **user)
        for facility in facilities:
            self.neo4j_client.add_node(
                str(facility["id"]), label="Facility", **facility
            )
        for device in devices:
            self.neo4j_client.add_node(str(device["id"]), label="Device", **device)
        for event in events:
            self.neo4j_client.add_node(str(event["id"]), label="Event", **event)

        for source, target in relationships.get("access", []):
            self.neo4j_client.add_edge(str(source), str(target), "ACCESS")
        for source, target in relationships.get("contains", []):
            self.neo4j_client.add_edge(str(source), str(target), "CONTAINS")
        for source, target in relationships.get("generated", []):
            self.neo4j_client.add_edge(str(source), str(target), "GENERATED")
        for source, target in relationships.get("triggered", []):
            self.neo4j_client.add_edge(str(source), str(target), "TRIGGERED")

    # ------------------------------------------------------------------
    # Detection
    # ------------------------------------------------------------------
    def detect_anomalies(self):
        """Return events whose degree exceeds ``min_degree``.

        The underlying graph is retrieved via the configured ``neo4j_client``
        which may connect to a real database or an in-memory representation.
        If :mod:`pandas` is available a :class:`pandas.DataFrame` is returned,
        otherwise a simple list of dictionaries is produced.  The returned rows
        contain ``event_id``, ``degree`` and ``is_anomaly`` keys.
        """

        graph = self.neo4j_client.get_graph()
        rows = []
        for node, data in graph.nodes(data=True):
            if data.get("label") == "Event":
                deg = graph.degree(node)
                if deg >= self.min_degree:
                    rows.append({"event_id": str(node), "degree": deg, "is_anomaly": True})

        try:  # pragma: no cover - optional dependency
            import pandas as pd  # type: ignore

            return pd.DataFrame(rows)
        except Exception:  # pragma: no cover - fallback when pandas missing
            return rows
